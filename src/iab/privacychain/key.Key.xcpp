// This is -*- c++ -*- nearly C++2a with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright (c) 2019 Verizon Media, Inc.  See the LICENSE statement nearby.
#divert <fpp>
#import std.uint64_t
namespace iab::privacychain::key {
  //
  // The key in the PrivacyChain database is a 64-bit number.
  //
  // Their natural on-the-wire streamed (printed) repreasentation is the decimalization of it.
  // This is helpful because the on-the-wire format of PrivacyChain and HyperLedger::Fabric payloads
  // winds up being JSON which can't deal with bit-level representations at all (weak sauce).
  //
  // Usage:
  //
  //   auto identifier = ...somehow...;
  //   key::Generator generate;
  //   auto key = generate(identifier);
  //
  //   auto &outbound = to_stream(std::cout, key);
  //   Key fill;
  //   auto &inbound = from_stream(std::cin, fill);
  //
  enum class Key : std::uint64_t;
}
#endiv
#divert <hpp>
#import nonstd.required.Character
#import nonstd.required.Character_Traits
#import std.basic_ostream
#import std.basic_istream
#import std.to_string
#import iab.privacychain.required
namespace iab::privacychain::key {
  inline auto to_string(Key) -> std::string;
  // Following C++20's std::chrono::to_stream(...),std::chrono::from_stream(...)
  // https://en.cppreference.com/w/cpp/chrono/system_clock/from_stream
  // and as such there is no operator<< or operator>>
  template<required::Character CHAR, required::Character_Traits TRAITS> inline auto to_stream(std::basic_ostream<CHAR, TRAITS> &, Key const &) -> std::basic_ostream<CHAR, TRAITS> &;
  template<required::Character CHAR, required::Character_Traits TRAITS> inline auto from_stream(std::basic_istream<CHAR, TRAITS> &, [[out]] Key &) -> std::basic_istream<CHAR, TRAITS> &;
}
#endiv
#divert <ipp>
#import std.ostringstream
namespace iab::privacychain {
  auto key::to_string(Key value) -> std::string {
    std::ostringstream buf;
    to_stream(buf, value);
    return buf.str();
  }
  template<required::Character CHAR, required::Character_Traits TRAITS> auto key::to_stream(std::basic_ostream<CHAR, TRAITS> &s, Key const &k) -> std::basic_ostream<CHAR, TRAITS> & {
    return s << (typename std::underlying_type<Key>::type) k;
  }
  template<required::Character CHAR, required::Character_Traits TRAITS> auto key::from_stream(std::basic_istream<CHAR, TRAITS> &s, Key &k) -> std::basic_istream<CHAR, TRAITS> & {
    return s >> (typename std::underlying_type<Key>::type &) k;
  }
}
#endiv
