// This is -*- c++ -*- nearly C++2a with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright (c) 2019 Verizon Media, Inc.  See the LICENSE statement nearby.
#divert <fpp>
#forward iab.privacychain.operation.Operation
namespace iab::privacychain::operation {
  //
  // A read (only) query on the data base; also see Operation<INVOKE>.
  //
  // May use locally-cached data.
  // May use process-local cached data
  // May use cluster-local cached data.
  //
  // When using a SQL data store ... may use data cached anywhere back to the origin server.
  // When using a Ledger database, does not invoke chaincode.
  //
  // The lifetime of the context must be longer than that of the Operation<QUERY>
  //
  // Usage:
  //
  //   Operation<QUERY> read{context};
  //   auto got = read(key);
  //   if (ok(got)) {
  //     auto payload = value(std::move(got));
  //     ...
  //   } else {
  //     auto ec = error_code(got);
  //     ...
  //   }
  //
  template<> class Operation<QUERY>;
}
#endiv
#divert <hpp>
#import iab.privacychain.operation.Basis
namespace iab::privacychain::operation {
  template<> class Operation<QUERY> : public Basis {
    using ancestor = Basis;
  public:
    inline explicit Operation(Context &);
    auto run(Function const &, Key const &) -> Outcome<Record> override;
    auto run(Function const &, Key const &, Record const &) -> Success override;
  };
}
#endiv
#divert <ipp>
namespace iab::privacychain::operation {
  Operation<QUERY>::Operation(Context &context) : ancestor{context} { }
}
#endiv
#divert <cpp>
#import hyperledger.fabric.peer.chaincode.query
#import iab.privacychain.constructor.generate
#import std.vector
#import std.byte
namespace iab::privacychain::operation {
  auto Operation<QUERY>::run(Function const &function, Key const &key) -> Outcome<Record> try {
    using Result = Outcome<Record>;
    auto called = hyperledger::fabric::peer::chaincode::query<std::vector<std::byte>>(context, constructor::generate(function, key));
    if (!ok(called)) {
      return Result{error_code(called)};
    }
#warning WRITETHIS parse the versioned schema and materialize a fully formed "latest" Value.
    return Result{value(std::move(called))};
  } catch (std::error_code const &ec) {
    return Outcome<Record>{ec};
  }
  auto Operation<QUERY>::run(Function const &function, Key const &key, Record const &record) -> Success try {
    auto called = hyperledger::fabric::peer::chaincode::query(context, constructor::generate(function, key, record));
    return !ok(called) ? Success{error_code(called)} : Success{SUCCESS};
  } catch (std::error_code const &ec) {
    return Success{ec};
  }
}
#endiv
