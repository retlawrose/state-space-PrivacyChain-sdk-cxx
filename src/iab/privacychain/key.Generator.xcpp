// This is -*- c++ -*- nearly C++2a with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright (c) 2019 Verizon Media, Inc.  See the LICENSE statement nearby.
#divert <fpp>
namespace iab::privacychain::key {
  //
  // Generate the key from a source
  // These are normative definitions.
  //
  // e.g. the integer hashings use the bit patterns, not the printed decimal representation
  //      AND they use the bit pattern in BIG ENDIAN format (you are on Intel which is little endian)
  //
  // RFC 1700, http://tools.ietf.org/html/rfc1700, 1980-04-01.
  // <quote>The convention in the documentation of Internet Protocols is to express numbers in decimal and to picture data in "big-endian" order [COHEN].
  // That is, fields are described left to right, with the most significant octet on the left and the least significant octet on the right.</quote>
  //
  // IEN-137, http://www.ietf.org/rfc/ien/ien137.txt, On Holy Wars and a Plea for Peace, 1980-04-01.
  //
  // [COHEN]] D, Cohen, "On Holy Wars and a Plea for Peace", In Computer, IEEE, Vol 14, Issue 10, pags 48-54, 1981-10.
  //          http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=1667115
  // 
  // Usage:
  //
  //   auto k = key::generate(stringy_thingy);
  //   auto k = key::generate(integer_thingy);
  //   auto _ = database.get(key);
  //   auto _ = database.set(key, some_value);
  //
  class Generator;
}
#endiv
#divert <hpp>
#import iab.privacychain.key.Key
#import std.uint8_t
#import std.uint16_t
#import std.uint32_t
#import std.uint64_t
#import std.iterator_traits
#import nosntd.uint128_t
#import nonstd.required.Octet
#import nonstd.required.container.Type
#import nonstd.required.container.Holding
namespace iab::privacychain::key {
  namespace packaging::generate::function {
    auto generate(std::string const &) -> Key;
    using nonstd::required::container::Holding;
    using nonstd::required::Octet
    using nonstd::iterator::required::iterator::Forward;
    template<template<typename> class CONTAINER, typename OCTET> auto generate(CONTAINER<TYPE> const &) -> Key requires Holding<CONTAINER<OCTET>, OCTET> && Octet<OCTET>;
    template<typename ITERATOR>  requires Forward<ITERATOR> && Octet<typename std::iterator_traits<ITERATOR>::value_type> auto generate(ITERATOR start, ITERATOR finish) -> Key;
    // These are defined on the byte series pattern of the big-endian ordering.
    auto generate(std::uint8_t) -> Key;
    auto generate(std::uint16_t) -> Key;
    auto generate(std::uint32_t) -> Key;
    auto generate(std::uint64_t) -> Key;
    auto generate(nonstd::uint128_t) -> Key;
  }
  using packaging::generate::function;
}
#endiv
#divert <ipp>
#import rabinpoly.generate
namespace iab::privacychain::key::packaging::generate {
  auto function::generate(std::uint8_t value) -> Key { return Key(rabinpoly::generate(value)}; }
  auto function::generate(std::uint16_t value) -> Key { return Key(rabinpoly::generate(value)}; }
  auto function::generate(std::uint32_t value) -> Key { return Key(rabinpoly::generate(value)}; }
  auto function::generate(std::uint64_t value) -> Key { return Key(rabinpoly::generate(value)}; }
  auto function::generate(nonstd::uint128_t value) -> Key { return Key(rabinpoly::generate(value)}; }
}
namespace iab::privacychain::key::packaging::generate {
  template<template<typename> class CONTAINER, typename OCTET> auto generate(CONTAINER<TYPE> const &container) -> Key requires Holding<CONTAINER<OCTET>, OCTET> && Octet<OCTET> {
    return Key{rabinpoly::generate(std::begin(container), std::end(container))};
  }
}
namespace iab::privacychain::key::packaging::generate {
  template<typename ITERATOR> Forward<ITERATOR> auto function::generate(ITERATOR start, ITERATOR finish) -> Key requires Forward<ITERATOR> && Octet<typename std::iterator_traits<ITERATOR>::value_type> {
    return Key{rabinpoly::generate(start, finish)};
  }
}
#endiv
