// This is -*- c++ -*- nearly C++2a with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright (c) 2019 Verizon Media, Inc.  See the LICENSE statement nearby.
#divert <hpp>
#import iab.privacychain.deserialize
#import iab.privacychain.History
namespace iab::privacychain {
  //
  // Deserialize the history blob
  // See acxiom_cc.go v1.0
  //
  // Specimen:
  //
  //   {"data": [
  //       {"txId":"2a2bab9a6ce2e022a505df5fa2c4deea94ee843d1463c5b499315d459198bb07", "collectData":PAYLOAD, "timestamp":"2019-03-06 01:35:00.166102034 +0000 UTC", "isDelete":"false"},
  //       {"txId":"345a58b9ad6fa6d28089a166e4be443a1f25185f7ab32de7f75971466c31fd4d", "collectData":PAYLOAD, "timestamp":"2019-03-06 01:35:39.630594093 +0000 UTC", "isDelete":"false"},
  //       {"txId":"3f167b4ffdb6f757baa185d4a455b69f2320607df694f5211a03c8cf7d4e6b68", "collectData":PAYLOAD, ...etc... },
  //       ...etc...
  //   }
  //
  template<> auto deserialize<History>(Outcome<Value>) -> Outcome<History>;
}
#endiv
#divert <cpp>
#import iab.privacychain.chaincode.v1 // constants
#import iab.privacychain.error.Code
#import iab.privacychain.time.Point
#import iab.privacychain.transaction.Identifier
#import iab.privacychain.transaction.Record
#import std.error_code
#import std.move
#import std.make_unique
#import json.parse
#import json.exception.Generic
template<> auto iab::privacychain::deserialize<iab::privacychain::History>(Outcome<Value> in) -> Outcome<History> {
  using Result = Outcome<History>;
  if (!ok(in)) {
    return Result{error_code(in)};
  }
  try {
    // If the payload is not an shaped appropriately then these will throw.
    // See the specimen above.
    //
    // SOMEWHERE ELSE ---> in = json::parse(json::failure::THROWN, value(in); <--- SOMEWHERE ELSE
    auto const &container = value(in);
    History history;
    using namespace chaincode::v1::constants;
    for (auto const &record : container[DATA]) {
      auto tx        = exceptional(deserialize<transaction::Identifier>(record[TXID]));
      auto collected = exceptional(deserialize<std::string>(record[COLLECTED]));  // NOT decoding as JSON
      auto stamp     = exceptional(deserialize<time::Point>(record[STAMP]));
      auto deleet    = exceptional(deserialize<bool>(record[DELEET]));
      history.emplace_back(std::make_unique<transaction::Record>(transaction::Record{std::move(tx), std::move(collected), std::move(stamp), std::move(deleet)}));
    }
    return Result{std::move(history)};
  } catch (std::error_code const &ec) {
    return Result{ec};
  } catch (json::exception::Generic const &) {
    return Result{std::error_code{error::Code::PAYLOAD_BAD_RECORD}};
  }
}
#endiv
